[demonstration video](https://youtu.be/0_wCxNo7rVM)

# Overview

The songs were played using the Riff structure, which contained a list of doubles for notes, and int length, and a float note_period. From here, I instantiated two Riffs: (1) song_to_play for the user to GET a song from the class server based on song_id and (2) song_to_create for the user to create their own Riff and POST to the class server. Our overarching state machine kept track of the PLAYBACK or RECORD mode. Additionally, I created three classes -- Button, SongIDGetter, and SongCreator -- each of which contain State Machines. The Button Class was coded in a previous weekly exercise and returns 1 if the button is pressed for a short duration and 2 if the button is pressed for a long duration. Two instances of the button class were initialized: for button1 and button2. button2 was responsible for switching between PLAYBACK and RECORD modes, and button1 was responsible for the state transitions within each mode, as will be specified.

## SongIDGetter Class
Within each iteration of loop(), we updated the button1 and button2 values as previously mentioned. Since the overarching state is initialized as PLAYBACK, I first called the update method (which contains the FSM logic) on the song_creator instance. From here, we are in State 0 - Message Display, where we provide the user instructions: "Long Press to input a song ID to play!" To reiterate, a long press returns 2 in the button class's update method. In this scenario, we would reset our variable query_string (the song_id used for our GET request) and transition into state 1 - Text Entry. I had an array storing the digits 0-9. Using the IMU reading, when the board is tilted to the right, I incremented the currently selected character (indexed by the char_index variable) by one ('1' -> '2', '2' -> '3', ..., '9' -> '0'). When the board is tiled to the left, I decremented the currently selected character by one ('0' -> '9', ..., '3' -> '2', '2' -> '1'). If the button press is short, then we would append the currently selected character to query_string, and if the button press is long, then we transition into State 2 - Send Query, a brief state that displays "Sending Query" to the user on the LCD Screen and transitions automatically to State 3 - Send/Receive Result. Using an HTTP GET request, we query with the song_id. From here, we parsed the response buffer to extract the note period (which comes before &) and used strtok to extract the note frequencies using the comma as a delimiter and stored them in the Riff's notes array. From here, I slightly modified the code from Lab 3 that played each note in the notes array. To ensure that the song looped over, I put the previous code in a while loop. I checked if button1 was ever pushed. If it was, I updated the stop_ variable to 1, and we would exit the loop after the current iteration of the song. We would return to state 0 and write the LEDC frequency to 0 to silence the arduino.

If a long press was detected in button2, we would transition from the PLAYBACK to RECORD state.


## SongCreator Class
The SongCreator state machine first started in State 0 - Message Display, which showed "Long Press to input a single note's duration!" as user instruction. We once again reset our variables and if a long press was detected in button1, we would transition to State 1- Note Duration Entry. Using the IMU's x reading, I magnified its magnitude by 100x and took its absolute value for a more practical range of duration values. If a short button press is detected, we set song_to_create's note_period to the current value displayed and transition to State 2 - input notes. Once again using the IMU's x readings, we first checked if the x value is between -0.1 and 0.1. If it was, we set new_note's frequency to 0 to insert silence in our song. Otherwise, we would find the x value's corresponding new_note based on the accel_thresholds we created in lab 3. Provided that we detect a short press, we would append the current new_note to song_to_create's notes. If a long press is detected, we transition to state 3 - Format and send query. Here, I reformatted the riff to be in the form "{note_period}&{notes separated by commas}" to pass into our POST request to the class server. After the song is posted, the response buffer (containing the artist name and song_id) is printed to notify the user of success and we transition to state 4 - Idle, where we write the LEDC frequency to 0 to silence the arduino and simply wait for a long press again to return to state 0.

If a long press was detected in button2, we would transition from the RECORD to PLAYBACK state.